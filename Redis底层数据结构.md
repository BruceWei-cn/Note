### Redis底层数据结构

##### String:

> String是二进制存储安全的，所以可以使用它来存储图片视频；

- SDS(Simple Dynamic String),因为C语言开发的redis没有字符串类型，所以SDS作为底层实现；
- 特性：
  - redis为字符分配空间的次数是小于等于字符串的长度N，而原C语言中的分配原则必为N。降低了分配次数提高了追加速度，代价就是多占用一些内存空间，且这些空间不会自动释放。
  - 二进制安全的
  - 高效的计算字符串长度(时间复杂度为O(1))
  - 高效的追加字符串操作。

##### List:

> 版本3.2以前：ziplist+linkedlist
>
> 版本3.2以后：quicklist数据结构（A doubly linked list of ziplists）由ziplist组成的双向链表，结合了ziplist+linkedList的优点
>
> listk可以用于实现消息队列，也可以用它的range命令来做分页查询；

- ziplist:由表头和N个entry节点和压缩列表尾部表示符zlend组成的一个*<u>**连续的内存块**</u>*；主要用于存储整数和表较短的字符串
- linkedlist:双向链表，插入删除修改前后指针即可，但查询效率为O(n)
- 总结：
  - quicklist就是一个双向链表结构，插入删除效率很高，查询效率O(n),但是访问两端时间复杂度O（1),对list多是poll&push操作；
  - 每个quicklist节点就是一个ziplist,具备压缩列表特性，quicklist每个节点都是以ziplist结构保存着数据，而每个ziplist又可以包含多个entry,简单来说quicklist节点保存的是一片数据而不是一个数据；

##### Hash:

> hash可以存储多个简直之间的映射，既可以存字符串又可以是数字，同时可以对散列存储的数字值进行增减操作；

- hash底层结构：
  - ziplist: 满足条件才使用，1.当键的个数小于hash-max-ziplisy-entries(默认512)；2.当所有值都小于hash-max-ziplist-value(默认64)
  - hashtable：时间结构复杂度O(1),但是会消耗比较多的内存空间，以空间换时间；

##### Set:

> 无序，不重复
>
> 可以用作去重，交集，并集访问元素共同特点等功能；

- hashtable: 通过散列表来保证set集合的每个key都是不重复的,*<u>只有键没有值</u>*；
- intset: 
  - 前提：set-max-intset-entries: 512;集合内entry个数必须小于512；
  - 存储整数的有序集合（int16, int32, int64),查找时间复杂度O(logn)；插入时可能涉及到升级（比如：原本int16,当你插入int32时每个元素都会升级为int32），此时会对内存重新分配，时间复杂度O(N); <u>*intset只支持升级不支持降级操作*</u>；
- dict;

##### ZSet:

> 有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member),每个成员都是各不相同的。有序集合的值则被称为分值（score），分值必须为浮点数。有序集合是redis里面唯一一个既可以根据成员访问元素(这一点和散列一样),又可以根据分值以及分值的排列顺序访问元素的结构；

- Zset地层数据结构：

  - ziplist: member&score两值组成节点,并按score顺序排列；

  - skiplist与dict结合：

    - <u>skiplist是一种跳表结构，用于有序性以及查找性能</u>，大多数情况下效率与平衡树类似；跳表总是从最高层开始，然后随着元素范围缩小，慢慢降到低层；

      > skiplist的实现包含以下几部分：
      >
      > - 表头（head）：指向头节点
      > - 表尾（tail）：指向尾节点
      > - 节点（node）：实际保存的元素节点，每个节点可以有多层，层数是在创建此节点的时候随机生成的一个数值，而且每一层都是一个指向后面某个节点的指针。
      > - 层（level）：目前表内节点的最大层数
      > - 长度（length）：节点的数量。

    - dict: 用来存储元素信息，dict访问时间复杂度O(1)

